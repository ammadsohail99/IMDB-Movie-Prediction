---
title: "Midterm"
output:
  html_document: default
  pdf_document: default
date: "2023-10-21"
---

```{r setup, include=FALSE}
# R Markdown Setup Script

# Ensure that all R chunks have echo enabled for visibility
knitr::opts_chunk$set(echo = TRUE)

# Set a seed for reproducible results in random processes
set.seed(42)

# Specify a Comprehensive R Archive Network (CRAN) mirror for downloading packages
options(repos = c(CRAN = "https://cran.r-project.org"))

# Check if the 'GGally' package is installed; install it if it's not
# 'require' is used to load the package quietly (without printing messages to the console)
if (!require("GGally", quietly = TRUE)) {
  install.packages("GGally")
}

# Load the 'GGally' package
library(GGally)

## R Markdown
```


```{r}
# Load necessary libraries
library(knitr)
library(stringr)
library(dplyr)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(tidyr)
library(wordcloud)
library(purrr)
library(ggfortify)
library(corrplot)
library(igraph)
library(ggraph)
require(car)
require(lmtest)
require(plm)
library(caTools)
library(boot)
library(broom)
```


```{r}
# The %>% operator is used in dplyr for chaining commands, passing the output of one function as input to the next

# Read the IMDB data from a CSV file
imdb <- read.csv("E:/Users/pc/Downloads/IMDB_data_Fall_2023.csv")

# Attach the dataframe for convenient variable referencing
attach(imdb)

# Remove genre dummy columns as they do not cover all the genres
imdb <- imdb[, -(27:39)]

# Step 1: Identify all unique genres
# - Pull out the genres column
# - Split the genres string into individual genres
# - Unlist to convert the list to a vector
# - Get unique genres

all_genres <- imdb %>%
  pull(genres) %>%
  str_split("\\|") %>%
  unlist() %>%
  unique()

# Step 2: Create a new column for each genre
# - Loop through each genre
for (genre in all_genres) {
  # Create a valid column name by concatenating 'genre_' with the genre name and replacing spaces with underscores
  column_name <- str_c("genre_", genre) %>% str_replace_all(" ", "_")
  
  # Add a new column to 'imdb'
  # - The column name is dynamically created using the above step
  # - The column contains 1 if the genre is present in the movie's genres, 0 otherwise
  imdb <- imdb %>%
    mutate(!!column_name := as.integer(str_detect(genres, fixed(genre))))
}
```


#Ensuring variable name consistency

```{r}
# Rename 'genre_Sci-Fi' to 'genre_Sci_Fi' for consistency in column naming
imdb$genre_Sci_Fi <- imdb$`genre_Sci-Fi`

# Remove the original 'genre_Sci-Fi' column
imdb <- imdb[, -c(39)]

# Remove the original 'genres' column (assuming it's at the 24th position)
imdb <- imdb[, -24]

```


#EDA

#Plotting histograms
```{r}

# Define a new, more varied color palette
color_palette <- brewer.pal(9, "Set1")

# Iterate over each column in the dataframe using seq_along()
for (i in seq_along(imdb)) {
  col_name <- names(imdb)[i]
  column_data <- imdb[[col_name]]

  # Check if the column is a factor or character, as histograms are for categorical data
  if (is.factor(column_data) || is.character(column_data)) {
    column_data <- factor(column_data) # Convert to factor for consistent handling

    # Create a dataframe with category counts
    category_counts <- table(column_data) %>%
      as.data.frame() %>%
      arrange(desc(Freq)) %>%
      mutate(category = reorder(column_data, Freq)) # Reorder categories by frequency

    # Limit to the top 20 categories if there are too many
    if (nrow(category_counts) > 20) {
      category_counts <- head(category_counts, 20)
    }

    # Create a histogram using ggplot2
    plot <- ggplot(category_counts, aes(x = category, y = Freq)) +
      geom_bar(stat = "identity", fill = color_palette[i %% length(color_palette) + 1]) + # Use geom_bar for histograms
      geom_text(aes(label = Freq), vjust = -0.5, size = 3) + # Add text labels
      labs(title = paste("Histogram for Top Categories in", col_name), x = "Category", y = "Frequency") + # Customize labels
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Improve x-axis label readability

    # Print the plot
    print(plot)
  }
}

```


#Plotting distribution with histograms for numerical columns
```{r}
# Retrieve column names from the 'imdb' dataframe
a <- names(imdb)

# Define a color palette
color_palette <- brewer.pal(9, "Set1")

# Loop through the first nine columns or the total number of columns if less than nine
for (i in 1:min(9, length(a))) {
  # Check if the current column is numeric
  if (is.numeric(imdb[[a[i]]])) {
    # Create a histogram plot
    plot <- ggplot(imdb, aes_string(x = a[i])) +
      geom_histogram(aes(y = ..density..), bins = 20, fill = color_palette[i]) +  # Histogram with density
      stat_function(fun = dnorm,  # Add a normal distribution curve
                    args = list(mean = mean(imdb[[a[i]]], na.rm = TRUE), 
                                sd = sd(imdb[[a[i]]], na.rm = TRUE)), 
                    color = "black", size = 1) +
      labs(title = paste("Histogram with Normal Curve for", a[i]), x = a[i], y = "Density") +  # Add labels
      theme_minimal()  # Use a minimal theme for aesthetics

    # Print the plot
    print(plot)
  }
}
```


#Plotting boxplots
```{r}
# Retrieve the column names from the 'imdb' dataframe
a <- names(imdb)

# Define a color palette
color_palette <- brewer.pal(9, "Set1")

# Loop through the first nine columns or the total number of columns if less than nine
for (i in 1:min(9, length(a))) {
  # Check if the current column is numeric
  if (is.numeric(imdb[[a[i]]])) {
    # Create a boxplot
    plot <- ggplot(imdb, aes(x = factor(1), y = .data[[a[i]]])) +
      geom_boxplot(fill = color_palette[i]) +  # Boxplot with specified fill color
      labs(title = paste("Boxplot for", a[i]), y = a[i], x = "") +  # Add title and axis labels
      theme_minimal() +  # Use a minimal theme for aesthetics
      theme(text = element_text(size = 12),  # Set text size for clarity
            axis.title.y = element_text(size = 14),  # Customize y-axis title size
            plot.title = element_text(size = 16, hjust = 0.5),  # Customize plot title
            axis.title.x = element_blank(),  # Remove x-axis title
            axis.text.x = element_blank(),  # Remove x-axis text
            axis.ticks.x = element_blank())  # Remove x-axis ticks

    # Print the plot
    print(plot)
  }
}

```


#Plotting histogram to observe distribution for the target variable
```{r}
# Define a color palette from "Set1" and select a specific color for the histogram
color_palette <- brewer.pal(9, "Set1")
histogram_color <- color_palette[1]  # First color from the palette

# Create a histogram plot of IMDb scores
ggplot(imdb, aes(x = imdb_score)) +
  geom_histogram(binwidth = 0.5, fill = histogram_color, color = "white") +  # Histogram settings
  labs(title = "Histogram of IMDb Scores", x = "IMDb Score", y = "Count") +  # Add title and axis labels
  theme_minimal() +  # Use a minimal theme for a clean look
  theme(text = element_text(size = 16),  # Set general text size
        axis.title = element_text(size = 18),  # Customize axis title size
        plot.title = element_text(size = 20, hjust = 0.5),  # Customize plot title
        axis.text = element_text(size = 14),  # Customize axis text size
        panel.grid.minor = element_blank(),  # Remove minor gridlines
        panel.grid.major.x = element_blank())  # Remove x-axis major gridlines

```


#Dummifying keywords based on top 20 keywords (with each dummy for one of the top 20 keyword
#and rest belong to others)


```{r}
# 1. Extract Keywords
# - Select the 'plot_keywords' column
# - Split keywords into lists and unnest
# - Trim whitespace from each keyword
keywords <- imdb %>%
  select(plot_keywords) %>%
  mutate(plot_keywords = strsplit(as.character(plot_keywords), '\\|')) %>%
  unnest(plot_keywords) %>%
  mutate(plot_keywords = trimws(plot_keywords))

# 2. Count Keywords
# - Group by keywords and count occurrences
# - Sort by descending frequency
keyword_counts <- keywords %>%
  group_by(plot_keywords) %>%
  summarise(n = n()) %>%
  arrange(desc(n))

# 3. Select Top Keywords
# - Select the top 20 keywords based on frequency
top_keywords <- head(keyword_counts, 20) %>% pull(plot_keywords)

# 4. Adjust the keywords
# - Keep only the top keywords or mark others as 'Other'
# - Deduplicate the list (remove repeating 'Other')
# - Add a row identifier for merging later
imdb <- imdb %>%
  mutate(
    adjusted_keywords = lapply(
      strsplit(as.character(plot_keywords), '\\|'),
      function(keyword_list) {
        adjusted_list <- sapply(keyword_list, function(keyword) {
          if (keyword %in% top_keywords) {
            return(keyword)
          } else {
            return('Other')
          }
        })
        unique(adjusted_list)
      }
    )
  ) %>%
  mutate(row_id = row_number())

# 5. Create Dummy Variables
# - Create a wide format dataframe with dummy variables for each keyword
# - Fill missing values with 0
imdb_dummies <- imdb %>%
  select(row_id, adjusted_keywords) %>%
  unnest(adjusted_keywords) %>%
  mutate(dummy = 1) %>%
  pivot_wider(id_cols = row_id, names_from = adjusted_keywords, values_from = dummy, values_fill = list(dummy = 0), names_prefix = "keyword_")

# Join the dummy variables with the original data
# - Remove the row identifier and adjusted_keywords column after joining
imdb <- left_join(imdb, imdb_dummies, by = "row_id") %>%
  select(-row_id, -adjusted_keywords)
```


```{r}
# Extract Keywords
# - Select the 'plot_keywords' column
# - Split keywords into lists, unnest them, and trim whitespace
keywords <- imdb %>%
  select(plot_keywords) %>%
  mutate(plot_keywords = strsplit(as.character(plot_keywords), '\\|')) %>%
  unnest(plot_keywords) %>%
  mutate(plot_keywords = trimws(plot_keywords))

# Count Keywords
# - Group by keywords and count occurrences
# - Sort by descending frequency
keyword_counts <- keywords %>%
  group_by(plot_keywords) %>%
  summarise(n = n()) %>%
  arrange(desc(n))

# Select Top 20 Keywords
# - Extract the top 20 most frequent keywords
top_keywords <- head(keyword_counts, 20)

# Create a Word Cloud for the top 20 keywords
# - words: the keywords to be used
# - freq: the frequency of each keyword
# - min.freq: the minimum frequency required for a word to be plotted
# - max.words: maximum number of words to be plotted
# - random.order: whether to plot words in random order
# - colors: color palette for the words
wordcloud(words = top_keywords$plot_keywords, freq = top_keywords$n, 
          min.freq = 1, max.words = 20, random.order = FALSE, 
          colors = brewer.pal(8, "Dark2"))

```


```{r}
# Rename columns for consistency by replacing spaces with underscores
imdb$keyword_high_school = imdb$`keyword_high school`
imdb$keyword_new_york_city = imdb$`keyword_new york city`
imdb$keyword_cult_film = imdb$`keyword_cult film`
imdb$keyword_serial_killer = imdb$`keyword_serial killer`

# Remove the original columns with the old names
imdb = imdb[,-c(51,54,56,62)]
```



```{r}
# Define a function to categorize maturity ratings
categorize_maturity_rating <- function(rating) {
  # Check if the rating is one of 'PG-13', 'PG', or 'R'
  if (rating %in% c('PG-13', 'PG', 'R')) {
    return(rating)
  } else {
    return('Others')
  }
}

# Apply the function to the 'maturity_rating' column
imdb$maturity_rating <- sapply(imdb$maturity_rating, categorize_maturity_rating)

# Dummify the 'maturity_rating' column
# - model.matrix is used to create dummy variables
dummy_vars <- model.matrix(~ maturity_rating - 1, data = imdb) %>%
              as.data.frame()

# Keep only 'PG-13', 'PG', and 'R' columns, if they exist
dummy_vars <- dummy_vars[, colnames(dummy_vars) %in% c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')]

# Create missing dummy columns and set them to zero if they don't exist
necessary_columns <- c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')
for (col in necessary_columns) {
  if (!col %in% colnames(dummy_vars)) {
    dummy_vars[[col]] <- 0
  }
}

# Combine the dummy variables with the original dataframe
imdb <- cbind(imdb, dummy_vars)

# Display the first few rows of the updated dataframe
head(imdb)
```


We also observed that the movie ID for The Rocket: The Legend of Rocket Richard and The Rocker is same, so we will modify the movieID of The Rocker so that movie ID can be used as an unique identifier for the dataframe
  
```{r}
# Update the 'movie_id' column
# - If 'movie_id' is 2667 and 'movie_title' is "The Rocker", change 'movie_id' to 2668
# - Otherwise, keep the current 'movie_id'
imdb <- mutate(imdb, movie_id = ifelse(movie_id == 2667 & movie_title == "The Rocker", 2668, movie_id))

```

Removing variables from the dataset which seem irrelevant

```{r}
# Remove specific columns from the 'imdb' dataframe
# The columns at positions 1, 2, 3, 6, 8, 17, 19, 21, and 23 are excluded
imdb <- imdb[,-c(1,2,3,6,8,17,19,21,23)]
```


```{r}
# Convert 'production_company' from a factor to a character vector, if necessary
imdb$production_company <- as.character(imdb$production_company)

# Count the occurrences of each production company in the dataset
production_counts <- as.data.frame(table(imdb$production_company))

# Rename the columns of 'production_counts' for better clarity
names(production_counts) <- c("production_company", "count")

# Categorize each production company as 'famous' or 'non-famous'
# - 'famous' if the company has produced 18 or more movies
# - 'non-famous' if the count is less than 18
production_counts$production_by <- ifelse(production_counts$count >= 18, 'famous', 'non-famous')

# Merge the 'production_by' information back into the original 'imdb' dataframe
# - Merge is based on the 'production_company' column
imdb <- merge(imdb, production_counts[, c("production_company", "production_by")], by = "production_company")

# Create a dummy variable for 'famous' production companies
# - The dummy variable is 1 for 'famous' and 0 for 'non-famous'
imdb$famous_production_company <- ifelse(imdb$production_by == 'famous', 1, 0)

```


```{r}
# Remove the original 'production_company' and 'plot_keywords' columns from the 'imdb' dataframe
imdb = imdb[,-c(1,17)]
```


```{r}

#We observed that there 1115 unique directors, with a large portion of directors directing 1 or 2 movies. Therefore, we decided to split the directors columns into 3 categories where extremely prolific is the director directing more than 2 movies. Very prolific is the director directing 2 movies and low prolific is the director director direction 1 or 0 movies.

# Convert 'director' column to a factor, if necessary
imdb$director <- as.factor(imdb$director)

# Calculate the number of movies directed by each director
director_counts <- table(imdb$director)

# Define a function to categorize directors based on the number of movies directed
categorize_director <- function(director_name) {
  count <- director_counts[director_name]
  if (count > 2) {
    return("Extremely Prolific")
  } else if (count == 2) {
    return("Very Prolific")
  } else {
    return("Low Prolific")
  }
}

# Categorize directors based on their counts
imdb$director_category <- sapply(imdb$director, categorize_director)

# Create dummy variables for each director category
imdb <- imdb %>%
  mutate(
    director_extremely_prolific = ifelse(director_category == "Extremely Prolific", 1, 0),
    director_very_prolific = ifelse(director_category == "Very Prolific", 1, 0),
    director_low_prolific = ifelse(director_category == "Low Prolific", 1, 0)
  )

# View the first few rows of the modified dataframe
head(imdb)
```


```{r}
# Convert 'distributor' column to a factor, if necessary
imdb$distributor <- as.factor(imdb$distributor)

# Define the threshold for categorization
threshold <- 40

# Calculate the number of movies distributed by each distributor
distributor_counts <- table(imdb$distributor)

# Define a function to categorize distributors based on the number of movies distributed
categorize_distributor <- function(distributor_name) {
  count <- distributor_counts[distributor_name]
  if (count > threshold) {
    return("Major Distributors")
  } else {
    return("Independent Distributors")
  }
}

# Apply the categorization function to each distributor
imdb$distributor_category <- sapply(imdb$distributor, categorize_distributor)

# Create a dummy variable for major distributors
# - 1 if the distributor is a major distributor, 0 otherwise
imdb$major_distributor <- ifelse(imdb$distributor_category == "Major Distributors", 1, 0)

# Display the first few rows of the updated dataframe
head(imdb)
```

```{r}
#Removing director category, production company and distribution company variables which contained the new custom categories we created. We have already created dummies using those custom categories.

# The columns at positions 63, 65, and 69 are excluded
imdb = imdb[,-c(63,65,69)]
```



```{r}
# Remove the 'languages' column from the 'imdb' dataframe as it is an almost unary predictor
imdb = imdb[,-c(5)]
```


```{r}
# Transform the 'country' column to categorize as 'USA' or 'Non-USA'
imdb <- imdb %>%
  mutate(country = ifelse(country == 'USA', 'USA', 'Non-USA'))

# Create a dummy variable for the 'country' column
# - 1 if the country is 'USA', 0 otherwise
imdb$country_usa <- ifelse(imdb$country == 'USA', 1, 0)

# Display the first few rows of the updated dataframe, focusing on 'country' and 'country_usa' columns
head(imdb[, c("country", "country_usa")])
```

```{r}
#Removing original country variable
imdb = imdb[,-c(5)]
```


```{r}
# Categorize the aspect ratios
imdb$aspect_ratio_category <- ifelse(imdb$aspect_ratio == 1.85, "1.85",
                                     ifelse(imdb$aspect_ratio == 2.35, "2.35", "Others"))

# Create dummy variables for 1.85 and 2.35 aspect ratios
imdb$aspect_ratio_1_85 <- ifelse(imdb$aspect_ratio_category == "1.85", 1, 0)
imdb$aspect_ratio_2_35 <- ifelse(imdb$aspect_ratio_category == "2.35", 1, 0)

# Now, if both dummy_1_85 and dummy_2_35 are 0, it means the movie belongs to the "Others" category.
```


```{r}
#Removing maturity_rating and aspect ratio column
imdb = imdb[,-c(5,6)]
```


```{r}
#Highly experienced - more than 6 movies, experienced 2 to 6 movies, less experienced means 1

# Count the number of movies per cinematographer and merge this info back into the original dataframe
imdb <- imdb %>%
  left_join(imdb %>%
              group_by(cinematographer) %>%
              summarise(num_movies = n()), by = "cinematographer")

# Create a new categorical variable based on the number of movies
imdb$cinematographer_experience <- ifelse(imdb$num_movies > 6, 'Highly experienced',
                                          ifelse(imdb$num_movies > 1, 'Experienced', 'Less experienced'))

# Create dummy variables. We exclude the first level to use it as a reference category (which will be 'Highly experienced' if your factor levels are ordered alphabetically)
imdb <- imdb %>%
  mutate(cinematographer_experienced = as.integer(cinematographer_experience == 'Experienced'),
         cinematographer_less_experienced = as.integer(cinematographer_experience == 'Less experienced'))

# View the first few rows of the modified dataframe
head(imdb[, c("cinematographer", "num_movies", "cinematographer_experience", "cinematographer_experienced", "cinematographer_less_experienced")])

#Removing cinematographer_experience, distribution companies and director column 
imdb = imdb[,-c(5,7,68)]
```

```{r}
#removing cinematographer original column
imdb = imdb[,-c(11)]
```


```{r}
# Create dummy variables for release_month using model.matrix
# The '-1' ensures we don't get an intercept column
dummies <- model.matrix(~ release_month - 1, data = imdb)

# Convert the matrix to a dataframe
dummies_df <- as.data.frame(dummies)

# Drop the column corresponding to May
dummies_df$release_monthMay <- NULL

# Bind the dummies to the original dataframe
imdb <- cbind(imdb, dummies_df)

# Now, the imdb dataframe will have new columns for each month (except May). If all these columns are 0, it indicates May.
```


```{r}
#Removing release_month original column
imdb = imdb[,-c(3)]
```


```{r}
#removing unnecessary column
imdb = imdb[,-c(64)]
```


```{r}
#Min-max scaling as a lot of dummies
# Select numeric columns to scale, excluding 'imdb_score'
numeric_columns <- imdb %>%
  select_if(~ is.numeric(.) && !identical(., imdb$imdb_score))

# Apply min-max scaling using purrr::map_df for consistency
scaled_data <- map_df(numeric_columns, ~ (. - min(., na.rm = TRUE)) / 
                      (max(., na.rm = TRUE) - min(., na.rm = TRUE)))

# Combine the scaled columns with the original dataframe
# Here, we replace the original columns with the scaled ones
imdb[names(scaled_data)] <- scaled_data

# View the first few rows of your scaled dataframe
head(imdb)

#This code will min-max scale all numeric columns in the imdb dataframe, excluding the imdb_score column, which is our target variable.
```

#Judging Skewness

```{r}
a=names(imdb)

for (i in 1:9) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    a1 = mean(imdb[[i]])
    a2 = median(imdb[[i]])
    if (a1-a2 > 0){
      b =  sprintf("%s is positively skewed", a[[i]])
      print(a1-a2)
    }
    else if (a1-a2 < 0){
      b =  sprintf("%s is negatively skewed", a[[i]])
      print(a1-a2)
    }
    else{
      b = sprintf("%s is not skewed", a[[i]])
    }
    cat(b, "\n")  # Print the assessment
  }
}
```
#Lets map out the outliers
#plotting q-q plots
```{r}
# Define the color palette
color_palette <- brewer.pal(9, "Set1")

a = names(imdb)

for (i in 1:min(9, length(a))) {
  if (is.numeric(imdb[[a[i]]])){
    # Create a QQ plot with enhanced aesthetics
    p <- ggplot(imdb, aes(sample = imdb[[a[i]]])) +
      stat_qq(color = color_palette[i]) + 
      stat_qq_line(color = color_palette[i], size = 1.2) +
      labs(title = paste("QQ Plot for", a[i]), x = "Theoretical Quantiles", y = "Sample Quantiles") +
      theme_minimal() +
      theme(text = element_text(size = 12),
            axis.title = element_text(size = 14),
            plot.title = element_text(size = 16, hjust = 0.5),
            panel.grid.minor = element_blank(),
            panel.grid.major = element_line(color = "grey", linetype = "dotted"))
    print(p)
  }
}
```

#Rows indices with outliers, for each column

```{r}
#Rows index for outliers in each column

#Initializing sums variable
sums = 0

for (i in 1:9) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    all_outliers = list()
    
    #Converting into z-score to see which rows are outliers
    z_scores = scale(imdb[[a[i]]])
    
    # Identify outliers based on a threshold (e.g., |Z-score| > 3)
    outliers = abs(z_scores) > 3
    
    #Which rows are outliers
    all_outliers = which(outliers)
    
    print(all_outliers)
    cat("\n")
    
    #Variable to see number of outliers for each variable
    num = length(all_outliers)
    result = sprintf("Number of outliers: %d", num)
    print(result)
    cat("\n")
    
    #Variable to store total number of outliers
    sums = sums + num
    
  }
}
#Printing total number of outliers
sprintf("Total number of outliers: %d",sums)
```

#Rows with outliers in more than 1 column

```{r}
#Printing the rows with outliers in more than 1 column

# Initialize the vectors
outlier_rows <- c()
all_outliers_list <- list()

for (i in 1:9) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    
    # Convert into z-score to see which rows are outliers
    z_scores <- scale(imdb[[a[i]]])
    
    # Identify outliers based on a threshold (e.g., |Z-score| > 3)
    outliers <- abs(z_scores) > 3
    
    # Append outlier row indices to the vector
    outlier_rows <- c(outlier_rows, which(outliers))
    
    # Store outliers for each column in a list for reference
    all_outliers_list[[a[i]]] <- which(outliers)
  }
}

# Count the frequency of each row index in the outlier_rows vector
row_counts <- table(outlier_rows)

# Identify rows with frequency greater than 1
multi_outlier_rows <- as.integer(names(row_counts[row_counts > 1]))

# Print the rows with outliers in more than one column
sprintf("The rows with more than 1 oultier is %d",multi_outlier_rows)

```


```{r}
#Removing the rows with columns having more than 1 outlier and also removing keywords_other

imdb = imdb[-c(40,87,128,823,1331,1360,1498,1692),]
imdb = imdb[,-c(31)]
```

```{r}
#Removing aspect ratio categorical column
imdb = imdb[,-c(60)]
```


# Checking correlation

```{r}
# Prepare data for correlation matrix
numeric_data <- imdb[sapply(imdb, is.numeric)]
numeric_data <- numeric_data[, !colnames(numeric_data) %in% "movie_id"]
numeric_data <- numeric_data[, sapply(numeric_data, function(x) length(unique(x[!is.na(x)])) > 1)]

# Compute the correlation matrix
cor_matrix <- cor(numeric_data, use = "pairwise.complete.obs", method = "pearson")

# Visualizing the correlation matrix with an improved color scheme
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
         col = colorRampPalette(brewer.pal(9, "Set1"))(200),  # Custom color range
         tl.col = "black", tl.srt = 45, tl.cex = 0.6)  # Adjust text label size and rotation

```

#Plotting correlogram

```{r}
# Selecting the relevant columns for the correlogram
selected_columns <- c("imdb_score", "movie_budget", "duration", "nb_news_articles", 
                      "actor1_star_meter", "actor2_star_meter", "actor3_star_meter", 
                      "nb_faces", "movie_meter_IMDBpro")
imdb_selected <- imdb[, selected_columns, drop = FALSE]

# Compute the correlation matrix
cor_matrix <- cor(imdb_selected, use = "pairwise.complete.obs", method = "pearson")

# Visualizing the correlation matrix as a correlogram
corrplot(cor_matrix, method = "circle", type = "upper", order = "hclust",
         col = brewer.pal(n = 8, name = "Set1"), 
         bg = "white", tl.col = "black", tl.srt = 45, tl.cex = 0.6,
         addCoef.col = "black")  # Add coefficient color
```

#Plotting correlation graph

```{r}
# Create a graph from the correlation matrix
cor_graph <- graph_from_adjacency_matrix(cor_matrix > 0.5, weighted = TRUE, mode = "undirected")

# Define colors from the Set1 palette
node_colors <- brewer.pal(9, "Set1")

# Plot the graph with enhanced aesthetics
ggraph(cor_graph, layout = "fr") +
  geom_edge_link(aes(width = weight), alpha = 0.5, color = "gray") +
  geom_node_point(aes(color = name), size = 4) +
  scale_color_manual(values = node_colors) +
  geom_node_text(aes(label = name), vjust = 1.8, size = 3, repel = TRUE) +
  theme_void() +
  ggtitle("Correlation Graph") +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r}
#Checking if there is/are any combination(s) with value > 0.50 for coorelation
library(reshape2)

cor_matrix = cor(imdb_selected, method = "pearson")

# Convert correlation matrix to long format
long_format <- melt(cor_matrix)
head(long_format)

# Filter correlations greater than 0.50 (in absolute terms) and exclude self-correlations
high_correlations <- long_format %>%
  filter(abs(value) > 0.50 & Var1 != Var2)

# Print the pairs with high correlations
print(high_correlations)
```


```{r}
imdb <- imdb %>%
  rename(maturity_ratingPG_13 = `maturity_ratingPG-13`)
```


```{r}
#Checking for non-linearity 
reg = lm(imdb_score~.,data = imdb)
summary(reg)

#residualPlots(reg)
# Uncomment to see residual plots, press return to proceed
```


```{r}
#Checking heteroskedasticity
ncvTest(reg)

#There is a high probability of heteroskedasticity
```


```{r}
#Correcting heteroskedasticity
coeftest(reg, vcov=vcovHC(reg, type='HC1'))
```



```{r}
#removing all keywords column
imdb = imdb[,-c(31:50)]
```


```{r}
# Create an empty vector to store all outlier indices
all_outliers <- c()

for (i in 1:9) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    # Converting into z-score to see which rows are outliers
    z_scores = scale(imdb[[a[i]]])
    
    # Identify outliers based on a threshold (e.g., |Z-score| > 3)
    outliers = abs(z_scores) > 3
    
    # Which rows are outliers
    column_outliers = which(outliers)
    
    print(column_outliers)
    cat("\n")
    
    # Append the outlier indices to the all_outliers vector
    all_outliers = c(all_outliers, column_outliers)
    
    # Variable to see the number of outliers for each variable
    num = length(column_outliers)
    result = sprintf("Number of outliers for column %s: %d", a[i], num)
    print(result)
    cat("\n")
  }
}

# Get unique outlier indices (since a row can be an outlier in multiple columns)
unique_outliers <- unique(all_outliers)

# Remove rows with outliers
imdb <- imdb[-unique_outliers, ]

# Print the total number of unique outlier rows
sprintf("Total number of unique outlier rows: %d", length(unique_outliers))
```

```{r}
# Final Model 
#Added +0.0001 in log terms because log of 0 is not possible

reg3 = lm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-aspect_ratio_1_85-director_low_prolific-release_monthOct-release_monthMar-release_monthJan-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = imdb)

summary(reg3)
```



```{r}
#Using train-test split
sample=sample.split(imdb$imdb_score, SplitRatio=0.8)
train_set=subset(imdb, sample==TRUE)
test_set=subset(imdb, sample==FALSE)

fit = lm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-aspect_ratio_1_85-director_low_prolific-release_monthOct-release_monthMar-release_monthJan-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = train_set)

#Mean squared error

actual=test_set$imdb_score
prediction=predict(fit, test_set)
squared_error=(actual-prediction)^2
mse=mean(squared_error)
mse
```


```{r}
#Using LOOCV 

fit1= glm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-aspect_ratio_1_85-director_low_prolific-release_monthOct-release_monthMar-release_monthJan-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = imdb)

mse=cv.glm(imdb, fit1)$delta[1]
mse
```


```{r}
# Diagnostic Plots
par(mfrow = c(2, 2))  # Optional: Arrange plots in a 2x2 grid
plot(reg3)
```


```{r}
# Tidy the model output to get a data frame
tidy_reg3 <- tidy(reg3)

# Define colors from the Set1 palette
color_palette <- brewer.pal(9, "Set1")

# Create a coefficient plot using ggplot2 with enhanced aesthetics
ggplot(tidy_reg3, aes(x = estimate, y = term)) +
  geom_point(aes(color = p.value), size = 3) +
  scale_color_gradientn(colors = color_palette) +
  geom_errorbarh(aes(xmin = estimate - std.error, xmax = estimate + std.error), height = 0.2) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(y = "Predictors", x = "Estimate", color = "P-Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```

```{r}
######## TEST DATASET & PREDICTION
```
 
 ---
title: "Midterm"
output: html_document
date: "2023-10-21"
---

## R Markdown
```{r}
# %>% - we use this to store function output and pass it to 

tests = read.csv("E:/McGill Material/Course/Fall 2023/Multivariate Stats/MidTerm Project/test_data_imdb_Fall_2023.csv")
attach(tests)
#Removing genres dummy as they are not covering all the genres
tests = tests[,-(27:39)]

# Step 1: Identify all unique genres
all_genres = tests %>%
  pull(genres) %>%
  str_split("\\|") %>%
  unlist() %>%
  unique()

# Step 2: For each genre, create a new column
for (genre in all_genres) {
  column_name <- str_c("genre_", genre) %>% str_replace_all(" ", "_")  # Create a valid column name
  tests <- tests %>%
    mutate(!!column_name := as.integer(str_detect(genres, fixed(genre))))
}
```


```{r}
#Removing original genres
tests = tests[,-(24)]
```

Dummifying keywords based on top 20 keywords (with each dummy for one of the top 20 keyword
and rest belong to others)


```{r}
# 1. Extract Keywords
keywords <- tests %>%
  select(plot_keywords) %>%
  mutate(plot_keywords = strsplit(as.character(plot_keywords), '\\|')) %>%
  unnest(plot_keywords) %>%
  mutate(plot_keywords = trimws(plot_keywords))

# 2. Count Keywords
keyword_counts <- keywords %>%
  group_by(plot_keywords) %>%
  summarise(n = n()) %>%
  arrange(desc(n))

# 3. Select Top Keywords
top_keywords <- head(keyword_counts, 20) %>% pull(plot_keywords)

# 4. Adjust the keywords, keeping only the top ones or marking as 'Other'
tests <- tests %>%
  mutate(
    adjusted_keywords = lapply(
      strsplit(as.character(plot_keywords), '\\|'),
      function(keyword_list) {
        adjusted_list <- sapply(keyword_list, function(keyword) {
          if (keyword %in% top_keywords) {
            return(keyword)
          } else {
            return('Other')
          }
        })
        # Deduplicate the list (remove repeating 'Other')
        return(unique(adjusted_list))
      }
    )
  ) %>%
  mutate(row_id = row_number())  # Add row identifier

# 5. Create Dummy Variables
tests_dummies <- tests %>%
  select(row_id, adjusted_keywords) %>%
  unnest(adjusted_keywords) %>%
  mutate(dummy = 1) %>%
  pivot_wider(id_cols = row_id, names_from = adjusted_keywords, values_from = dummy, values_fill = list(dummy = 0), names_prefix = "keyword_")

# Join the dummy variables with the original data
tests <- left_join(tests, tests_dummies, by = "row_id") %>%
  select(-row_id, -adjusted_keywords)  # Remove the row identifier and adjusted_keywords column


```


```{r}
#There are almost 80-90% of values in R, PG and PG13,so we can classify other categories into a new category called others

# Function to categorize maturity ratings
categorize_maturity_rating <- function(rating) {
  if (rating %in% c('PG-13', 'PG', 'R')) {
    return(rating)
  } else {
    return('Others')
  }
}

# Apply the function to the 'maturity_rating' column
tests$maturity_rating <- sapply(tests$maturity_rating, categorize_maturity_rating)

# Dummify the 'maturity_rating' column
dummy_vars <- model.matrix(~ maturity_rating - 1, data = tests) %>%
              as.data.frame()

# Keep only 'PG-13', 'PG', and 'R' columns, if they exist
dummy_vars <- dummy_vars[, colnames(dummy_vars) %in% c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')]

# If the columns don't exist in the dummy_vars (because they might not be present in the original data), 
# we need to create them and set them to zero.
necessary_columns <- c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')
for (col in necessary_columns) {
  if (!col %in% colnames(dummy_vars)) {
    dummy_vars[[col]] <- 0
  }
}

# Bind the dummy variables with the original dataframe
tests <- cbind(tests, dummy_vars)

# This will print the first few rows of your dataframe
head(tests)
```

Removing variables from the dataset which seem irrelevant

```{r}
tests = tests[,-c(1,2,3,6,8,17,19,21,23)]
```


```{r}
#Classified the production companies that produced more than 18 movies into famous category and the ones with lesser than 18 movies as non-famous. Created dummy with 1 = famous and 0 = non-famous

# Ensure that production_company is a character vector, not a factor
tests$production_company <- as.character(tests$production_company)

# Count occurrences of each production company
production_counts <- as.data.frame(table(tests$production_company))

# Name the columns for clarity
names(production_counts) <- c("production_company", "count")

# Categorize as 'famous' or 'non-famous'
production_counts$production_by <- ifelse(production_counts$count >= 18, 'famous', 'non-famous')

# Merge this information back into the original dataframe
tests <- merge(tests, production_counts[, c("production_company", "production_by")], by = "production_company")

# Create a dummy variable for 'famous'
tests$famous_production_company <- ifelse(tests$production_by == 'famous', 1, 0)
```


```{r}
#Removing original production_company and plot_keywords column
tests = tests[,-c(1,17)]
```


```{r}
#We observed that there 1115 unique directors, with a large portion of directors directing 1 or 2 movies. Therefore, we decided to split the directors columns into 3 categories where extremely prolific is the director directing more than 2 movies. Very prolific is the director directing 2 movies and low prolific is the director director direction 1 or 0 movies.

# First, ensure that 'director' is a factor
tests$director <- as.factor(tests$director)

# Calculate the number of movies for each director
director_counts <- table(tests$director)

# Function to categorize directors based on director counts
categorize_director <- function(director_name) {
  count <- director_counts[director_name]
  if (count > quantiles[2]) {
    return("Extremely Prolific")
  } else if (count > quantiles[1]) {
    return("Medium Prolific")
  } else {
    return("Less Prolific")
  }
}

# Calculate the quantiles based on the number of movies directed
quantiles <- quantile(director_counts, probs = c(0.3, 0.7))

# Categorize directors
tests$director_category <- sapply(tests$director, categorize_director)

# Create dummy variables
tests <- tests %>%
  mutate(
    director_extremely_prolific = ifelse(director_category == "Extremely Prolific", 1, 0),
    director_very_prolific = ifelse(director_category == "Medium Prolific", 1, 0)
  )

# View the first few rows of the modified dataframe
head(tests)
```


```{r}
# Ensure that 'distributor' is a factor
tests$distributor <- as.factor(tests$distributor)

# Define the threshold
threshold <- 40

# Calculate the number of movies for each distributor
distributor_counts <- table(tests$distributor)

# Function to categorize distributors
categorize_distributor <- function(distributor_name) {
  count <- distributor_counts[distributor_name]
  if (count > threshold) {
    return("Major Distributors")
  } else {
    return("Independent Distributors")
  }
}

# Categorize distributors
tests$distributor_category <- sapply(tests$distributor, categorize_distributor)

# Create a dummy variable for major distributors
tests$major_distributor <- ifelse(tests$distributor_category == "Major Distributors", 1, 0)

# View the first few rows of the modified dataframe
head(tests)
```

```{r}
#Removing director category, production company and distribution company variables which contained the new custom categories we created. We have already created dummies using those custom categories.

tests = tests[,-c(56,58,61)]
```



```{r}
#Removing languages as it is an almost unary predictor

tests = tests[,-c(5)]
```


```{r}
# Transform the 'country' column
tests <- tests %>%
  mutate(country = ifelse(country == 'USA', 'USA', 'Non-USA'))

# Create a dummy variable
tests$country_usa <- ifelse(tests$country == 'USA', 1, 0)

# View the first few rows of the modified dataframe
head(tests[, c("country", "country_usa")])
```


```{r}
#Removing original country variable
tests = tests[,-c(5)]
```


```{r}

# Categorize the aspect ratios
tests$aspect_ratio_category <- ifelse(tests$aspect_ratio == 1.85, "1.85",
                                     ifelse(tests$aspect_ratio == 2.35, "2.35", "Others"))

# Create dummy variables for 1.85 and 2.35 aspect ratios
tests$aspect_ratio_1_85 <- ifelse(tests$aspect_ratio_category == "1.85", 1, 0)
tests$aspect_ratio_2_35 <- ifelse(tests$aspect_ratio_category == "2.35", 1, 0)

# Now, if both dummy_1_85 and dummy_2_35 are 0, it means the movie belongs to the "Others" category.
```


```{r}
#Removing maturity_rating and aspect ratio column
tests = tests[,-c(5,6)]
```


```{r}
#Highly experienced - more than 6 movies, experienced 2 to 6 movies, less experienced means 1

# Count the number of movies per cinematographer and merge this info back into the original dataframe
tests <- tests %>%
  left_join(tests %>%
              group_by(cinematographer) %>%
              summarise(num_movies = n()), by = "cinematographer")

# Create a new categorical variable based on the number of movies
tests$cinematographer_experience <- ifelse(tests$num_movies > 6, 'Highly experienced',
                                          ifelse(tests$num_movies > 1, 'Experienced', 'Less experienced'))

# Create dummy variables. We exclude the first level to use it as a reference category (which will be 'Highly experienced' if your factor levels are ordered alphabetically)
tests <- tests %>%
  mutate(cinematographer_experienced = as.integer(cinematographer_experience == 'Experienced'),
         cinematographer_less_experienced = as.integer(cinematographer_experience == 'Less experienced'))

# View the first few rows of the modified dataframe
head(tests[, c("cinematographer", "num_movies", "cinematographer_experience", "cinematographer_experienced", "cinematographer_less_experienced")])
```


```{r}
#Removing distribution companies and director column 
tests = tests[,-c(5,7)]
```


```{r}
#removing cinematographer original column
tests = tests[,-c(11)]
```


```{r}
# Trim whitespace from the release_month column
tests$release_month <- trimws(tests$release_month)

# Create a binary dummy variable for November
tests$November <- as.numeric(tests$release_month == "Nov")
```


```{r}
#Removing release_month original column
tests = tests[,-c(3)]
```


```{r}
#Unnecessary column
tests = tests[,-c(53)]
```


```{r}
#Making movie budget a numerical column
tests$movie_budget = as.integer(gsub(",","",tests$movie_budget))
```


```{r}
#unnecessary column
tests = tests[,-c(56)]
```


```{r}
# Select numeric columns to scale, excluding 'tests_score' and the 48th, 49th, and 50th columns
numeric_columns <- tests %>%
  select_if(~ is.numeric(.) && !identical(., tests$imdb_score)) %>%
  select(-c(47, 48, 49,50,51,55,56,57))

# Apply min-max scaling using purrr::map_df for consistency
scaled_data <- map_df(numeric_columns, ~ (. - min(., na.rm = TRUE)) / 
                      (max(., na.rm = TRUE) - min(., na.rm = TRUE)))

# Combine the scaled columns with the original dataframe
# Here, we replace the original columns with the scaled ones
tests[names(scaled_data)] <- scaled_data

# View the first few rows of your scaled dataframe
head(tests)


#This code will min-max scale all numeric columns in the tests dataframe, excluding the tests_score column, which is your target variable.
```


```{r}
#Removing num_movies column
tests = tests[,-c(55)]
```


```{r}
#removing all keywords column
tests = tests[,-c(24:44)]
```


```{r}
# Store the column names of training data
train_cols <- colnames(imdb)

# Add missing columns to test_data with 0s
for (col in train_cols) {
  if (!col %in% colnames(tests)) {
    tests[[col]] <- 0
  }
}

# Remove extra columns from test_data
tests <- tests[, train_cols]
```


```{r}
#This is the final model

reg3 = lm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-aspect_ratio_1_85-director_low_prolific-release_monthOct-release_monthMar-release_monthJan-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = imdb)

summary(reg3)

predicted_scores = predict(reg3, newdata = tests)
tests$predicted_imdb_score = predicted_scores
predicted_scores
```

#Showing predicted ratings as a table

```{r}
less = read.csv("E:/McGill Material/Course/Fall 2023/Multivariate Stats/MidTerm Project/test_data_imdb_Fall_2023.csv")
tests$movie_title = less$movie_title

library(kableExtra)

# Assuming 'tests' dataframe has columns 'movie_title' and 'predicted_imdb_score'
# Select the relevant columns and maybe take a subset for a concise table
movie_ratings <- tests %>%
  select(movie_title, predicted_imdb_score) %>%
  head(20)  # Display first 20 rows as an example

# Create a kable and style it
kable_styled <- kable(movie_ratings, format = "html", caption = "Movie Titles and Predicted IMDb Scores") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F) %>%
  column_spec(1, bold = T) %>%
  column_spec(2, color = "blue")

# Print the styled table
print(kable_styled)


```


